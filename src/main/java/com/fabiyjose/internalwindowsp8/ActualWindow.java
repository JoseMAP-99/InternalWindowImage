/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.fabiyjose.internalwindowsp8;

import java.awt.Dimension;
import java.awt.Point;
import org.opencv.core.Mat;

/**
 *
 * @author Fabián y José María
 */
public class ActualWindow extends javax.swing.JInternalFrame {
    
    private final int width;
    private final int height;
    private boolean changed = false;
    private Mat filtered = null;
    public ActualWindow(int width, int height, String title, Point pointC) {
        initComponents();
        this.setTitle(title); 
        this.width = width;
        this.height = height;
        this.setSize(new Dimension(this.width, this.height));
        this.setLocation(pointC);
        this.setClosable(true);
        this.setIconifiable(true); 
    }
    
    public void viewActImage(Mat image){
        canvas.viewImage(image);
    }    
    
    public void applyFilterImage(Mat actIMage, int umb){
        this.filtered = canvas.applyFilter(umb, actIMage);         
    }
    
    public Mat getFiltered(){
        return this.filtered;
    }
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        canvas = new com.fabiyjose.internalwindowsp8.Canvas();

        addHierarchyBoundsListener(new java.awt.event.HierarchyBoundsListener() {
            public void ancestorMoved(java.awt.event.HierarchyEvent evt) {
            }
            public void ancestorResized(java.awt.event.HierarchyEvent evt) {
                formAncestorResized(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentMoved(java.awt.event.ComponentEvent evt) {
                formComponentMoved(evt);
            }
        });

        javax.swing.GroupLayout canvasLayout = new javax.swing.GroupLayout(canvas);
        canvas.setLayout(canvasLayout);
        canvasLayout.setHorizontalGroup(
            canvasLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 684, Short.MAX_VALUE)
        );
        canvasLayout.setVerticalGroup(
            canvasLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 482, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(canvas, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(canvas, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentMoved(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentMoved
        if (changed) return;        
        updateWindow(evt.getComponent().getParent().getSize());        
        changed = false;        
    }//GEN-LAST:event_formComponentMoved

    private void formAncestorResized(java.awt.event.HierarchyEvent evt) {//GEN-FIRST:event_formAncestorResized
        if (changed) return;        
        updateWindow(evt.getChanged().getSize());  
        changed = false;
    }//GEN-LAST:event_formAncestorResized
    
    private void updateWindow(Dimension size){
        int[] res = getCoords(getCorners(this.getLocation()), size);
        
        int xTemp = res[0];
        int yTemp = res[1];
        
        if (res[2] == 1){
            this.setLocation(xTemp, yTemp);
        }else if (size.width == this.width && size.height == this.height){
            this.setLocation(0, 0);
        }
    }
    
    private int[] getCoords(Point[] pointsWin, Dimension size){
        int xTemp = 0;
        int yTemp = 0;
        boolean enter = false;
        
        /*
         *LEFT_UPPER_CORNER
         */
        Point pt = pointsWin[0];
        
        //RIGHT SIDE -> TOP, MIDDLE, BOTTOM
        if(pt.x > size.width){
            if(pt.y < 0){
                xTemp = size.width - this.width;  
                yTemp = 0;
                enter = true;
            }
            if(pt.y < size.height){
                xTemp = size.width - this.width;  
                yTemp = pt.y;
                enter = true;
            }
            if(pt.y > size.height){
                xTemp = size.width - this.width;  
                yTemp = size.height - this.height;
                enter = true;
            }            
        }
        
        //LEFT SIDE -> TOP, MIDDLE, BOTTOM
        if(pt.x < 0){
            if(pt.y < 0){
                xTemp = 0; 
                yTemp = 0;
                enter = true;
            }
            if(pt.y < size.height){
                xTemp = 0; 
                yTemp = pt.y;
                enter = true;
            }
            if(pt.y > size.height){
                xTemp = 0;  
                yTemp = size.height - this.height;
                enter = true;
            }            
        }
        
        //TOP SIDE
        if(pt.x < size.width && pt.y < 0){
            xTemp = pt.x;
            yTemp = 0;
            enter = true;
        }
        
        //BOTTOM SIDE
        if(pt.x < size.width && pt.y > size.height){
            xTemp = pt.x;
            yTemp = size.height - this.height;
            enter = true;
        }
          
        
        /*
         *RIGHT_BOTTOM_CORNER
         */
        Point pt1 = pointsWin[1];  
        
        //RIGHT SIDE -> TOP, MIDDLE, BOTTOM
        if(pt1.x > size.width){
            if(pt1.y < 0){
                xTemp = size.width - this.width;  
                yTemp = 0;
                enter = true;
            }
            if(pt1.y < size.height){
                xTemp = size.width - this.width;  
                yTemp = pt1.y-this.height;
                enter = true;
            }
            if(pt1.y > size.height){
                xTemp = size.width - this.width;  
                yTemp = size.height - this.height;
                enter = true;
            }            
        }
        
        //LEFT SIDE -> TOP, MIDDLE, BOTTOM
        if(pt1.x < 0){
            if(pt1.y < 0){
                xTemp = 0; 
                yTemp = 0;
                enter = true;
            }
            if(pt1.y < size.height){
                xTemp = 0; 
                yTemp = pt1.y-this.height;
                enter = true;
            }
            if(pt1.y > size.height){
                xTemp = 0;  
                yTemp = size.height - this.height;
                enter = true;
            }            
        }
        
        //TOP SIDE
        if(pt1.x < size.width && pt1.y < 0){
            xTemp = pt1.x-this.width;
            yTemp = 0;
            enter = true;
        }
        
        //BOTTOM SIDE
        if(pt1.x < size.width && pt1.y > size.height){
            xTemp = pt1.x-this.width;
            yTemp = size.height - this.height;
            enter = true;
        }
        
        int val = (enter)? 1:0;
        return new int[]{xTemp, yTemp, val};
    }
    
    private Point[] getCorners(Point leftUC){
        Point rigthBottom = new Point(leftUC.x + this.width, leftUC.y + this.height);
        
        return new Point[]{leftUC, rigthBottom};
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private com.fabiyjose.internalwindowsp8.Canvas canvas;
    // End of variables declaration//GEN-END:variables
}
